<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>在CentOS 7 x64中搭建Mumble语音服务器</title>
    <link href="/2020/10/25/%E5%9C%A8CentOS-7-x64%E4%B8%AD%E6%90%AD%E5%BB%BAMumble%E8%AF%AD%E9%9F%B3%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2020/10/25/%E5%9C%A8CentOS-7-x64%E4%B8%AD%E6%90%AD%E5%BB%BAMumble%E8%AF%AD%E9%9F%B3%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>上篇介绍过在CentOS 7 x64上搭建TeamSpeak 3 服务器的全部流程，详情可以查看以下两篇专栏。</p><p>今天我们来看另一款语音通讯服务Mumble。</p><p>跟TeamSpeak 3 类似，Mumble是一款支持自行架设的语音通信软件，支持绝大多数操作系统（包括Android和iOS）。它的亮点是在保持高质量通信和加密的情况下，内置优秀的In-game Overlay，实测可以吊打TeamSpeak 3自带的Overwolf。另外的优秀之处在于它是一款开源软件，对同时在线人数并无限制。与之形成对比的是TeamSpeak 3 服务器免费使用的前提是只有一个实例且同时在线人数不超过32人。如果你需要搭建一个语音服务器同时需要多于32人同时在线，那Mumble是一个不错的选择。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>一个域名指向Mumble所在服务器的IP地址并确保成功解析</li><li>vim或nano或者其它你喜欢的编辑器</li></ul><h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><p>以root用户运行，先是下载最新的release（<a href="https://github.com/mumble-voip/mumble/releases">点这里查看最新release</a>），linux服务器版本murmur：</p><pre><code class="hljs shell">wget https://github.com/mumble-voip/mumble/releases/download/1.3.0/murmur-static_x86-1.3.0.tar.bz2tar -vxjf ./murmur-static_x86-1.3.0.tar.bz2sudo mkdir /usr/local/murmursudo cp -r ./murmur-static_x86-1.3.0/* /usr/local/murmur/sudo cp ./murmur-static_x86-1.3.0/murmur.ini /etc/murmur.ini</code></pre><p>创建murmur用户和组等内容：</p><pre><code class="hljs shell">sudo groupadd -r murmursudo useradd -r -g murmur -m -d /var/lib/murmur -s /sbin/nologin murmursudo mkdir /var/log/murmursudo chown murmur:murmur /var/log/murmursudo chmod 0770 /var/log/murmur</code></pre><h2 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h2><h3 id="修改murmur-ini中的内容"><a href="#修改murmur-ini中的内容" class="headerlink" title="修改murmur.ini中的内容"></a>修改<code>murmur.ini</code>中的内容</h3><pre><code class="hljs shell">vim /etc/murmur.ini</code></pre><p>在<code>murmur.ini</code>中，确保如下内容，其中host对应之前准备好的域名，serverpassword设为空时没有密码：</p><pre><code class="hljs shell">database=/var/lib/murmur/murmur.sqlitelogfile=/var/log/murmur/murmur.logpidfile=/var/run/murmur/murmur.pid...port=64738...uname=murmurhost=mumble.demo.comserverpassword=demo</code></pre><h3 id="创建murmur服务"><a href="#创建murmur服务" class="headerlink" title="创建murmur服务"></a>创建murmur服务</h3><pre><code class="hljs shell">sudo vim /etc/systemd/system/murmur.service</code></pre><p>在<code>murmur.service</code>中填入以下内容，保存后退出：</p><pre><code class="hljs shell">[Unit]Description=Mumble Server (Murmur)Requires=network-online.targetAfter=network-online.target mariadb.service time-sync.target[Service]User=murmurType=forkingExecStart=/usr/local/murmur/murmur.x86 -ini /etc/murmur.iniPIDFile=/var/run/murmur/murmur.pidExecReload=/bin/kill -s HUP $MAINPIDRestartSec=15Restart=always[Install]WantedBy=multi-user.target</code></pre><p>在很多系统中/var/run 会在重启后被清空。为了在重启后重新生成pid目录，以root权限创建配置文件：</p><pre><code class="hljs shell">sudo vim /etc/tmpfiles.d/murmur.conf</code></pre><p>在这个配置文件中写入：</p><pre><code class="hljs shell">d /var/run/murmur 775 murmur murmur</code></pre><p>保存后退出。</p><h3 id="日志轮替"><a href="#日志轮替" class="headerlink" title="日志轮替"></a>日志轮替</h3><p>为避免日志文件过多造成的困扰，创建配置文件：</p><pre><code class="hljs shell">sudo vim/etc/logrotate.d/murmur</code></pre><p>写入以下内容，保存后退出：</p><pre><code class="hljs shell">/var/log/murmur/*log &#123;    su murmur murmur    dateext    rotate 4    missingok    notifempty    sharedscripts    delaycompress    postrotate        /bin/systemctl reload murmur.service &gt; /dev/null 2&gt;/dev/null || true    endscript&#125;</code></pre><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><p>此处防火墙设置的端口需要和系统配置文件<code>/etc/murmur.ini</code>里面的端口保持一致。如果你在配置文件中修改了端口，请在以下文件中对端口也进行修改以保持一致。</p><pre><code class="hljs shell">sudo vim /etc/firewalld/services/murmur.xml</code></pre><p>默认端口为64738，写入以下内容，保存后退出：</p><pre><code class="hljs shell">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;service&gt;        &lt;short&gt;Murmur&lt;/short&gt;        &lt;description&gt;Mumble Server (Murmur)&lt;/description&gt;        &lt;port protocol=&quot;tcp&quot; port=&quot;64738&quot; /&gt;&lt;!-- Reminder: Update /etc/murmur.ini so that it uses the same ports --&gt;        &lt;port protocol=&quot;udp&quot; port=&quot;64738&quot; /&gt;&lt;/service&gt;</code></pre><p>添加以下规则到防火墙并重载使其生效：</p><pre><code class="hljs shell">sudo firewall-cmd --permanent --add-service=murmursudo firewall-cmd --reload</code></pre><h3 id="收尾工作"><a href="#收尾工作" class="headerlink" title="收尾工作"></a>收尾工作</h3><p>更新系统使我们刚才的设置生效：</p><pre><code class="hljs shell">sudo systemd-tmpfiles --create /etc/tmpfiles.d/murmur.confsudo systemctl daemon-reload</code></pre><h3 id="开机自启动"><a href="#开机自启动" class="headerlink" title="开机自启动"></a>开机自启动</h3><pre><code class="hljs shell">sudo systemctl enable murmur.service</code></pre><p>开始murmur服务：</p><pre><code class="hljs shell">sudo systemctl start murmur.service</code></pre><p>停止murmur服务：</p><pre><code class="hljs shell">sudo systemctl start murmur.service</code></pre><p>停止开机自启动：</p><pre><code class="hljs shell">sudo systemctl disable murmur.service</code></pre><h2 id="服务器管理员"><a href="#服务器管理员" class="headerlink" title="服务器管理员"></a>服务器管理员</h2><p>至少成功运行<code>murmur</code>服务一次，然后去log中找到密码，密码是第一次运行时自动生成的：</p><pre><code class="hljs shell">vim /var/log/murmur/murmur.log</code></pre><p>其中<code>&lt;W&gt;2020-03-06 23:53:13.049 1 =&gt; Password for &#39;SuperUser&#39; set to &#39;PASSWORD&#39;</code>这一条写明了用户名<code>SuperUser</code>的密码是<code>PASSWORD</code>。</p><h3 id="修改SuperUser密码"><a href="#修改SuperUser密码" class="headerlink" title="修改SuperUser密码"></a>修改SuperUser密码</h3><pre><code class="hljs shell">/usr/local/murmur/murmur.x86 -ini /etc/murmur.ini -supw Your_Password [srv]</code></pre><p>替换其中的Your_Password为你自己的密码即可。</p><h3 id="成为管理员"><a href="#成为管理员" class="headerlink" title="成为管理员"></a>成为管理员</h3><p>在成功运行了murmur服务，拿到了SuperUser密码后，打开Mumble客户端，完成证书的创建或者导入工作。在Mumble主界面选择<code>服务器</code>–&gt; <code>连接</code>–&gt; <code>添加</code>，在弹出的选项卡里填入以下内容：</p><ul><li>地址：<strong>mumble.demo.com</strong></li><li>端口：<strong>64738</strong></li><li>用户名：<strong>你的用户名</strong>（这是你在服务器中显示的名字）</li><li>别名：<strong>你的用户名@mumble.demo.com</strong></li></ul><p>填好后点<code>连接</code>。</p><p>当你连入了服务器后右键单击自己的用户名，选择”注册”并同意。</p><p>断开当前连接，然后在服务器选项卡新添加一个服务器，填入以下内容：</p><ul><li>地址：<strong>mumble.demo.com</strong></li><li>端口：<strong>64738</strong></li><li>用户名：<strong>SuperUser</strong></li><li>别名：<strong><a href="mailto:&#83;&#x75;&#x70;&#x65;&#114;&#x55;&#x73;&#x65;&#114;&#x40;&#109;&#117;&#109;&#x62;&#108;&#x65;&#x2e;&#100;&#101;&#x6d;&#111;&#x2e;&#99;&#x6f;&#x6d;">&#83;&#x75;&#x70;&#x65;&#114;&#x55;&#x73;&#x65;&#114;&#x40;&#109;&#117;&#109;&#x62;&#108;&#x65;&#x2e;&#100;&#101;&#x6d;&#111;&#x2e;&#99;&#x6f;&#x6d;</a></strong></li></ul><p>在弹出密码框时输入<code>SuperUser</code>的密码。</p><p>在服务器列表中右键点击<code>Root</code>频道，选择<code>编辑</code>–&gt;<code>分组</code>：</p><p>在分组的下拉菜单中选中<code>admin</code>，在左下角的<code>成员</code>下拉菜单中，输入前面在服务器注册的用户名并按回车。</p><p>断开当前连接，连接收藏夹里别名为：<strong>你的用户名@mumble.demo.com</strong>的服务器。</p><p>恭喜！你的账号<code>你的用户名</code>现在获得了服务器的管理员权限。</p>]]></content>
    
    
    <categories>
      
      <category>语音</category>
      
      <category>教程</category>
      
      <category>搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CentOS</tag>
      
      <tag>服务器</tag>
      
      <tag>Mumble</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TeamSpeak 3 服务器管理员权限丢失了怎么办？7步帮你找回</title>
    <link href="/2020/10/25/TeamSpeak-3-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86%E5%91%98%E6%9D%83%E9%99%90%E4%B8%A2%E5%A4%B1%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F7%E6%AD%A5%E5%B8%AE%E4%BD%A0%E6%89%BE%E5%9B%9E/"/>
    <url>/2020/10/25/TeamSpeak-3-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86%E5%91%98%E6%9D%83%E9%99%90%E4%B8%A2%E5%A4%B1%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F7%E6%AD%A5%E5%B8%AE%E4%BD%A0%E6%89%BE%E5%9B%9E/</url>
    
    <content type="html"><![CDATA[<h2 id="找回服务器管理权限"><a href="#找回服务器管理权限" class="headerlink" title="找回服务器管理权限"></a>找回服务器管理权限</h2><ol><li><p>如果你拥有server query的访问权限，,在步骤4中只执行第一句；如果你拥有server query的密码但却不记得用户名，请记住server query默认的用户名为<code>serveradmin</code>，然后请在步骤4中只执行第二句.</p></li><li><p>进入服务器TeamSpeak 3所在的文件夹</p><pre><code class="hljs shell">cd /opt/teamspeak3-server_linux_amd64</code></pre></li><li><p>首先关闭TeamSpeak 3服务。如果已经把TeamSpeak 3作为服务添加到系统里，请停止服务：</p><pre><code class="hljs shell">systemctl stop teamspeak.service</code></pre><p>如果没有作为服务运行，请执行以下来停止TeamSpeak 3：</p><pre><code class="hljs shell">./ts3server_startscript.sh stop</code></pre></li><li><p>用以下命令启动TeamSpeak 3服务端：</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 第一句，仅适用于知道serveradmin密码的情况</span>./ts3server_minimal_runscript.sh<span class="hljs-meta">#</span><span class="bash"> 第二句，适用于不知道serveradmin密码的情况</span>./ts3server_minimal_runscript.sh serveradmin_password=yOuR_nEwP@ssw0rd<span class="hljs-meta">#</span><span class="bash"> 这一步操作会重置你的`serveradmin`密码，请自行替换`yOuR_nEwP@ssw0rd`为你想要的密码。</span></code></pre></li><li><p>打开任意telnet客户端，比如PuTTy.</p><pre><code class="hljs shell">telnet 你的服务器IP:10011login serveradmin yOuR_nEwP@ssw0rd...use 1</code></pre><ul><li>密码是你刚刚重设的密码</li><li>选择teamSpeak instance，默认为1，输入<code>use 1</code>并回车</li></ul></li><li><p>现在输入以下命令来生成token</p><pre><code class="hljs shell">tokenadd tokentype=0 tokenid1=6 tokenid2=0</code></pre><p>这一步会生成新的token并打印在telnet客户端界面，复制好后进入客户端，连接到你自己的服务器，然后选择“权限” –&gt; “使用权限秘钥”，完成！</p></li><li><p>在此之后关闭./ts3server_minimal_runscript.sh，使用你正常的方式启动TeamSpeak 3服务端即可。</p></li></ol><h2 id="如何避免服务器权限丢失？"><a href="#如何避免服务器权限丢失？" class="headerlink" title="如何避免服务器权限丢失？"></a>如何避免服务器权限丢失？</h2><ul><li><p>在获取服务器权限以后登录TeamSpeak 3客户端并连接服务器，在“权限” –&gt; “权限秘钥”创建一个新的服务器组Server Admin的密钥（Privilege Key）并保存好，以备不时之需。</p></li><li><p>使用myTeamSpeak账号自动同步自己的管理员权限，具体设置在客户端的“工具” –&gt; “设置” –&gt; “myTeamSpeak”中可以找到。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>语音</category>
      
      <category>教程</category>
      
      <category>搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CentOS</tag>
      
      <tag>TeamSpeak</tag>
      
      <tag>服务器</tag>
      
      <tag>权限</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TeamSpeak 3 服务器架设全流程新手教程2020年10月版</title>
    <link href="/2020/10/25/TeamSpeak-3-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E8%AE%BE%E5%85%A8%E6%B5%81%E7%A8%8B%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B2020%E5%B9%B410%E6%9C%88%E7%89%88/"/>
    <url>/2020/10/25/TeamSpeak-3-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E8%AE%BE%E5%85%A8%E6%B5%81%E7%A8%8B%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B2020%E5%B9%B410%E6%9C%88%E7%89%88/</url>
    
    <content type="html"><![CDATA[<p>众所周知我们在和狐朋狗友并(互)肩(相)作(坑)战(害)的时候交流和沟通极其重要，否则一个不小心就是闭麦听歌一人九杀哀鸿遍野举目无亲的人间悲剧。队友之间的交流工具除了游戏内语音(In-game VoIP)之外那就是各种桌面通讯软件了。要说明白我为什么选择<code>TeamSpeak</code>这款软件，那就要盘点一下曾使用过的同类软件了（不全，但多少具有一些代表性）。</p><ol><li><strong><code>YY语音</code>**。YY作为历史悠久的老牌通讯软件（2008年发布[1]），它的用户群体非常大，通讯难度也不高，质量还是不错的。但我的亲身体验是随着YY的一步步壮大，各种乱七八糟的广告铺天盖地洒满你的桌面，甚至推送的一部分广告都达到了有碍观瞻的地步（本来就蔡，你个憨憨还弄这么多广告烦我）。总体来看，</strong><code>YY语音</code>**带来的用户体验非常差。</li><li><strong><code>Discord</code>**。</strong><code>Discord</code><strong>有一个显著的特点是其使用了Electron[2]架构，这让</strong><code>Discord</code><strong>拥有了可以在多平台上运行，又可以在浏览器中运行。</strong><code>Discord</code><strong>的运营因为极度尊重用户隐私还一度成为一些从事非法活动人员的指定通讯软件。后来由于一些众所周知的原因，自2018年7月开始大陆地区无法访问</strong><code>Discord</code>**。</li><li><strong><code>Steam语音</code>**。既然要打gogo，那</strong><code>Steam语音</code><strong>总可以用吧？确实，</strong><code>Steam语音</code><strong>随着在2018年7月25日推出的一波聊天系统大更新产生了巨大的变化，音频编码器选择了和</strong><code>Discord</code><strong>一样的<code>Opus</code>，保证音频质量更高的同时还加强了音频加密从而保护隐私。这么看来好处真的颇多，那为什么我不推荐呢？主要原因有二，其一，Steam好友服务经常无故中断，一些国家和地区的好友进入群组语音聊天时会偶发性掉线，很影响体验；其二，</strong><code>Steam语音</code>**自带语音感应功能，然而预设档位太少，只有高中低三个档位，完全无法满足“语音感应”这个功能在复杂场景下的需求。</li><li>**<code>QQ、微信语音</code>**。这个不用多说了，跟家人朋友聊聊天吹吹水可以，但是用做游戏通讯有时会遇到莫名其妙激活某个快捷键而切出游戏，遇到其他人来语音、视频通讯请求时强制切出游戏等等烦恼。毕竟不是为游戏通讯设计，确实不能成为第一选择。</li></ol><p>这里我要吹一下<code>TeamSpeak</code>，因为它优点真的太多。资源占用低（实测能达到**<code>Discord</code>**十分之一内存占用量），连接快捷（通过分享服务器/频道链接可以快速进入服务器/频道，无需添加好友），自带<code>Opus</code>音频解码器，服务器/频道可根据需求设置语音加密，纯净无广告，自带<code>Overwolf</code>游戏内语音显示(In-game Display)，细致可随意调节的“语音感应激活”功能告别通讯底噪和键盘噪音，频道内每一个用户的音量都可以单独调节……[3]</p><p>说完了选择**<code>TeamSpeak</code><strong>的原因，下面让我们看看如何在服务器端搭建一个免费的</strong><code>TeamSpeak</code>**服务器吧！</p><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><p>以下将以<code>CentOS 7 x64</code> 系统为例，其它系统搭建过程类似不再赘述。</p><blockquote><p><strong>为保证服务安全，请不要使用<code>root</code>账户安装并配置<code>TeamSpeak</code>服务器！</strong></p></blockquote><p>使用工具（以<code>xShell</code>为例）用<code>root</code>用户登录服务器并执行以下操作：</p><ol><li>更新系统，这可能要花些时间</li></ol><pre><code class="hljs linux">yum update -y</code></pre><ol start="2"><li>安装必须工具</li></ol><pre><code class="hljs linux">yum install vim wget perl tar net-tools bzip2 -y</code></pre><h2 id="2-开始安装"><a href="#2-开始安装" class="headerlink" title="2. 开始安装"></a>2. 开始安装</h2><ol><li>首先需要创建一个普通用户<code>teamspeak</code>，密码请按自己需求设置</li></ol><pre><code class="hljs linux">useradd teamspeakpasswd teamspeak</code></pre><ol start="2"><li>切换至<code>/opt</code>目录下</li></ol><pre><code class="hljs linux">cd &#x2F;opt</code></pre><ol start="3"><li>下载最新服务端软件包（目前最新版本3.12.1，以最新版本为准）</li></ol><pre><code class="hljs linux">wget https:&#x2F;&#x2F;files.teamspeak-services.com&#x2F;releases&#x2F;server&#x2F;3.12.1&#x2F;teamspeak3-server_linux_amd64-3.12.1.tar.bz2</code></pre><ol start="4"><li>解压最新服务端软件包并删除压缩包</li></ol><pre><code class="hljs linux">tar -xjvf teamspeak3-server_linux_amd64-3.12.1.tar.bz2 &amp;&amp; rm teamspeak3-server_linux_amd64-3.12.1.tar.bz2</code></pre><ol start="5"><li>赋予普通用户<code>teamspeak</code>权限，并进入该目录</li></ol><pre><code class="hljs linux">chown -R teamspeak:teamspeak teamspeak3-server_linux_amd64 &amp;&amp; cd &#x2F;opt&#x2F;teamspeak3-server_linux_amd64 &amp;&amp; su teamspeak</code></pre><h2 id="3-配置与运行"><a href="#3-配置与运行" class="headerlink" title="3. 配置与运行"></a>3. 配置与运行</h2><ol><li>在开始之前，需要先同意<code>TeamSpeak</code>许可条款</li></ol><pre><code class="hljs linux">touch .ts3server_license_accepted</code></pre><ol start="2"><li>自动配置数据库并启动<code>TeamSpeak</code>服务器</li></ol><pre><code class="hljs linux">.&#x2F;ts3server_startscript.sh start</code></pre><ol start="3"><li>屏幕上会出现两条<code>IMPORTANT</code>的信息，请注意保管并记牢！其中<code>Token</code>是激活服务器管理员的重要凭证！</li></ol><pre><code class="hljs linux">[teamspeak@vultr teamspeak3-server_linux_amd64]$ .&#x2F;ts3server_startscript.sh startStarting the TeamSpeak 3 serverTeamSpeak 3 server started, for details please view the log file[teamspeak@vultr teamspeak3-server_linux_amd64]$ ------------------------------------------------------------------                      I M P O R T A N T                           ------------------------------------------------------------------               Server Query Admin Account created                          loginname&#x3D; &quot;serveradmin&quot;, password&#x3D; &quot;mYk0+CCa&quot;------------------------------------------------------------------------------------------------------------------------------------                      I M P O R T A N T                           ------------------------------------------------------------------      ServerAdmin privilege key created, please use it to gain       serveradmin rights for your virtualserver. please      also check the doc&#x2F;privilegekey_guide.txt for details.       token&#x3D;rNB3AHfFblRdkSwuMTXyrCGIdFuBn9SOdAt2V3HW------------------------------------------------------------------</code></pre><h2 id="4-配置防火墙"><a href="#4-配置防火墙" class="headerlink" title="4. 配置防火墙"></a>4. 配置防火墙</h2><p><code>CentOS 7</code> 不再使用<code>iptables</code>，取而代之的是<code>firewalld</code>。</p><ol><li>首先找到 <code>default zone</code></li></ol><pre><code class="hljs linux">firewall-cmd --get-default-zone</code></pre><ol start="2"><li>酌情打开与<code>TeamSpeak</code>服务相关的端口</li></ol><blockquote><ul><li>9987/udp for Voice.</li><li>30033/tcp for Filetransfer.</li><li>10011/tcp for ServerQuery.</li><li>41144/tcp for TSDNS (optional)</li></ul></blockquote><pre><code class="hljs linux">firewall-cmd --zone&#x3D;public --permanent --add-port&#x3D;9987&#x2F;udpfirewall-cmd --zone&#x3D;public --permanent --add-port&#x3D;10011&#x2F;tcpfirewall-cmd --zone&#x3D;public --permanent --add-port&#x3D;30033&#x2F;tcpfirewall-cmd --zone&#x3D;public --permanent --add-port&#x3D;41144&#x2F;tcp</code></pre><ol start="3"><li>重载<code>firewalld</code>以使其生效</li></ol><pre><code class="hljs linux">firewall-cmd --reload</code></pre><h2 id="5-自启动配置"><a href="#5-自启动配置" class="headerlink" title="5. 自启动配置"></a>5. 自启动配置</h2><ol><li>以<code>root</code>身份创建并编辑文件</li></ol><pre><code class="hljs linux">SU rootvim &#x2F;lib&#x2F;systemd&#x2F;system&#x2F;teamspeak.service</code></pre><ol start="2"><li>在该文件中写入如下内容：（按<code>i</code>进入编辑模式，编辑完成后按<code>ESC</code>退出编辑模式，接着输入<code>:wq</code>保存并退出vim编辑器）</li></ol><pre><code class="hljs config">[Unit]Description&#x3D;Teamspeak, The most superior online voice communication solution.After&#x3D;network.target[Service]User&#x3D;teamspeakGroup&#x3D;teamspeakWorkingDirectory&#x3D;&#x2F;opt&#x2F;teamspeak3-server_linux_amd64&#x2F;ExecStart&#x3D;&#x2F;opt&#x2F;teamspeak3-server_linux_amd64&#x2F;ts3server_startscript.sh startExecStop&#x3D;&#x2F;opt&#x2F;teamspeak3-server_linux_amd64&#x2F;ts3server_startscript.sh stopPIDFile&#x3D;&#x2F;opt&#x2F;teamspeak3-server_linux_amd64&#x2F;ts3server.pidType&#x3D;forkingRestartSec&#x3D;15Restart&#x3D;always[Install]WantedBy&#x3D;multi-user.target</code></pre><ol start="3"><li><code>systemd</code>需要被重新加载以生效</li></ol><pre><code class="hljs linux">systemctl daemon-reload</code></pre><ol start="4"><li>开启服务自启动</li></ol><pre><code class="hljs linux">systemctl enable teamspeak.service</code></pre><p><em>启动 <code>TeamSpeak</code>：</em></p><pre><code class="hljs linux">systemctl start teamspeak.service</code></pre><p><em>停止 <code>TeamSpeak</code>：</em></p><pre><code class="hljs linux">systemctl stop teamspeak.service</code></pre><p><em>重启 <code>TeamSpeak</code>：</em></p><pre><code class="hljs linux">systemctl restart teamspeak.service</code></pre><h2 id="6-TSDNS域名设置"><a href="#6-TSDNS域名设置" class="headerlink" title="6. TSDNS域名设置"></a>6. TSDNS域名设置</h2><p>首先你需要拥有一个顶级域名或者可以配置的二级域名。这里以顶级域名为例：</p><blockquote><p><code>demo.com</code>是此处例子中的顶级域名，示例目标是可以通过<code>ts.demo.com</code>访问已经搭建好的<code>TeamSpeak</code>服务器</p></blockquote><ol><li>转到<code>tsdns</code>文件夹</li></ol><pre><code class="hljs linux">cd tsdns</code></pre><ol start="2"><li>创建文件<code>tsdns_settings.ini</code> ：（按<code>i</code>进入编辑模式，编辑完成后按<code>ESC</code>退出编辑模式，接着输入<code>:wq</code>保存并退出vim编辑器）</li></ol><pre><code class="hljs linux">vim tsdns_settings.ini</code></pre><p>在该文件中，以下面的格式配置域名（其中域名和IP地址请自行更换）：</p><pre><code class="hljs config">ts.demo.com&#x3D;1.1.1.1:$PORT</code></pre><ol start="3"><li>接下来去域名DNS服务商增加域名的<code>SRV</code>记录，此处以<code>cloudflare.com</code>为例，其它DNS服务商类似。其中需要将<code>1.1.1.1</code>替换为你的服务器地址，将<code>demo.com</code>替换为你的域名。</li></ol><ul><li><p>在DNS里对应域名下添加<code>A</code>记录，内容如下：</p><table><thead><tr><th>Type</th><th>Name</th><th>Content</th><th>Proxy status</th></tr></thead><tbody><tr><td>A</td><td>ts</td><td>1.1.1.1</td><td>Proxied</td></tr></tbody></table></li><li><p>在DNS里添加一条<code>SRV</code>记录，内容如下：</p><table><thead><tr><th>Type</th><th>Service</th><th>Protocol</th><th>Name</th><th>TTL</th><th>Priority</th><th>Weight</th><th>Port</th><th>Target</th></tr></thead><tbody><tr><td>SRV</td><td>_ts3</td><td>UDP</td><td>demo.com</td><td>Auto</td><td>0</td><td>0</td><td>9987</td><td>ts.demo.com</td></tr></tbody></table></li></ul><ol start="4"><li>后台运行<code>tsdns</code>服务：</li></ol><pre><code class="hljs linux">screen -AmdS tsdns .&#x2F;tsdnsserver</code></pre><ol start="5"><li>将<code>tsdns</code>添加至开机自启动计划任务</li></ol><pre><code class="hljs linux">crontab -e</code></pre><p>在打开的文件末尾添加如下字句：</p><pre><code class="hljs linux">@reboot &#x2F;opt&#x2F;teamspeak3-server_linux_amd64&#x2F;tsdns&#x2F;tsdnsserver</code></pre><p>保存并退出后可通过<code>crontab -l</code>来列出当前生效的计划任务。</p><p>到这里为止，服务器的架设就都完成了，接下来请使用TeamSpeak的客户端连接自己的服务器吧！</p><p>[1] <a href="https://baike.baidu.com/item/YY%E8%AF%AD%E9%9F%B3">https://baike.baidu.com/item/YY%E8%AF%AD%E9%9F%B3</a>, 2020年2月1日</p><p>[2] <a href="https://zh.wikipedia.org/wiki/Discord">https://zh.wikipedia.org/wiki/Discord</a>, 2020年2月1日</p><p>[3] <a href="https://www.teamspeak.com/en/features/overview/">https://www.teamspeak.com/en/features/overview/</a>, 2020年10月5日</p>]]></content>
    
    
    <categories>
      
      <category>语音</category>
      
      <category>教程</category>
      
      <category>搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CentOS</tag>
      
      <tag>TeamSpeak</tag>
      
      <tag>服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS 7 x64 利用宝塔安装gitea</title>
    <link href="/2020/10/25/CentOS-7-x64-%E5%88%A9%E7%94%A8%E5%AE%9D%E5%A1%94%E5%AE%89%E8%A3%85gitea/"/>
    <url>/2020/10/25/CentOS-7-x64-%E5%88%A9%E7%94%A8%E5%AE%9D%E5%A1%94%E5%AE%89%E8%A3%85gitea/</url>
    
    <content type="html"><![CDATA[<h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><ul><li><p>准备域名并解析到服务器IP（code.demo.com –&gt; <code>IP</code>)</p></li><li><p>确保宝塔已经安装并安装好lnmp环境</p></li><li><p>确保mySQL版本至少为5.5.3</p></li><li><p>安装git</p></li><li><p>首先检查CentOS 7系统中安装的git版本：</p><pre><code class="hljs shell">git --version</code></pre><p>git version 1.8.3.1</p></li></ul><p>  <strong>从IUS存储库安装git的方法</strong></p><p>  IUS是一个社区项目，为Enterprise Linux发行版的新版精选软件提供RPM包，该项目的目的是为红帽企业Linux（RHEL）和CentOS创建高质量的RPM包。</p><p>  1、删除旧的git：</p>  <pre><code class="hljs shell">sudo yum remove git</code></pre><p>  2、添加IUS CentOS 7 repo：</p>  <pre><code class="hljs shell">sudo yum install  https://centos7.iuscommunity.org/ius-release.rpmsudo yum install  git2u-all</code></pre><p>  安装git2u-all软件包后检查git版本：</p>  <pre><code class="hljs shell">git --version</code></pre><p>  git version 2.16.5</p><p>  如上所述，当前版本Git是2.16.5，如果要安装最新的Git版本，最好是下载源代码并安装。</p><h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><ul><li><p>在宝塔中新建网站code.demo.com，创建数据库MySQL，字符集选择utf8_general_ci</p><p><img src="Snipaste_2020-02-22_12-01-26.png" alt="Snipaste_2020-02-22_12-01-26"></p><p>远程下载gitea</p><pre><code class="hljs shell">cd /www/wwwroot/code.demo.com/wget -O gitea https://dl.gitea.io/gitea/master/gitea-master-linux-amd64chmod +x gitea</code></pre><p>成功之后运行gitea，访问<code>http://ip:3000</code>即可测试。</p><pre><code class="hljs shell">./gitea web</code></pre></li></ul><ul><li>在DNS服务商处绑定code.demo.com到服务器IP地址后，打开宝塔面板网站的SSL，使用Let’s Encrypt进行证书签名</li></ul><p><img src="Snipaste_2020-02-25_21-54-52.png" alt="Snipaste_2020-02-25_21-54-52"></p><ul><li>接着打开宝塔网站的配置文件，示例配置文件内容如下：</li></ul><pre><code class="hljs shell">server&#123;listen 443 ssl http2;listen 80;  client_max_body_size 100000m;    server_name code.demo.com;    index index.php index.html index.htm default.php default.htm default.html;    root /www/wwwroot/code.demo.com;        #SSL-START SSL相关配置，请勿删除或修改下一行带注释的404规则    #error_page 404/404.html;    #HTTP_TO_HTTPS_START    if ($server_port !~ 443)&#123;        rewrite ^(/.*)$ https://$host$1 permanent;    &#125;    #HTTP_TO_HTTPS_END    ssl_certificate    /www/server/panel/vhost/cert/code.demo.com/fullchain.pem;    ssl_certificate_key    /www/server/panel/vhost/cert/code.demo.com/privkey.pem;    ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3;    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;    ssl_prefer_server_ciphers on;    ssl_session_cache shared:SSL:10m;    ssl_session_timeout 10m;    error_page 497  https://$host$request_uri;    #SSL-END        #ERROR-PAGE-START  错误页配置，可以注释、删除或修改    #error_page 404 /404.html;    #error_page 502 /502.html;    #ERROR-PAGE-END        #PHP-INFO-START  PHP引用配置，可以注释或修改    # include enable-php-00.conf;    #PHP-INFO-END        #REWRITE-START URL重写规则引用,修改后将导致面板设置的伪静态规则失效    # include /www/server/panel/vhost/rewrite/code.demo.com.conf;    #REWRITE-END        #禁止访问的文件或目录    location ~ ^/(\.user.ini|\.htaccess|\.git|\.svn|\.project|LICENSE|README.md)    &#123;        return 404;    &#125;        #一键申请SSL证书验证目录相关设置    location ~ \.well-known&#123;        allow all;    &#125;        location ~ .*\.(gif|jpg|jpeg|png|bmp|swf|ico)$    &#123;        expires      30d;        error_log off;        access_log /dev/null;        proxy_pass http://127.0.0.1:3000;    &#125;        location ~ .*\.(js|css)?$    &#123;        expires      12h;        error_log off;        access_log /dev/null;         proxy_pass http://127.0.0.1:3000;    &#125;        location / &#123;        proxy_pass      http://127.0.0.1:3000;        proxy_redirect      off;        proxy_set_header Host      $host;        proxy_set_header X-Real-IP $remote_addr;        &#125;        access_log  /www/wwwlogs/code.demo.com.log;    error_log  /www/wwwlogs/code.demo.com.error.log;    &#125;</code></pre><p>其中<code>proxy_pass        http://127.0.0.1:3000</code>用来代理访问3000端口的请求。</p><ul><li>新建一个systemd服务文件，内容如下：</li></ul><pre><code class="hljs shell">[unit]Description=Gitea (Git with a cup of tea)After=syslog.targetAfter=network.targetAfter=mysqld.service<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">##</span></span><span class="hljs-meta">#</span><span class="bash"> Don<span class="hljs-string">&#x27;t forget to add the database service requirements</span></span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">##</span></span><span class="hljs-meta">#</span><span class="hljs-meta">#</span><span class="bash">Requires=mysql.service</span><span class="hljs-meta">#</span><span class="bash">Requires=mariadb.service</span><span class="hljs-meta">#</span><span class="bash">Requires=postgresql.service</span><span class="hljs-meta">#</span><span class="bash">Requires=memcached.service</span><span class="hljs-meta">#</span><span class="bash">Requires=redis.service</span><span class="hljs-meta">#</span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">##</span></span><span class="hljs-meta">#</span><span class="bash"> If using socket activation <span class="hljs-keyword">for</span> main http/s</span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">##</span></span><span class="hljs-meta">#</span><span class="hljs-meta">#</span><span class="bash">After=gitea.main.socket</span><span class="hljs-meta">#</span><span class="bash">Requires=gitea.main.socket</span><span class="hljs-meta">#</span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">##</span></span><span class="hljs-meta">#</span><span class="bash"> (You can also provide gitea an http fallback and/or ssh socket too)</span><span class="hljs-meta">#</span><span class="hljs-meta">#</span><span class="bash"> An example of /etc/systemd/system/gitea.main.socket</span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">##</span></span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#</span></span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># [Unit]</span></span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># Description=Gitea Web Socket</span></span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># PartOf=gitea.service</span></span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#</span></span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># [Socket]</span></span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># Service=gitea.service</span></span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># ListenStream=&lt;some_port&gt;</span></span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># NoDelay=true</span></span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#</span></span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># [Install]</span></span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># WantedBy=sockets.target</span></span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#</span></span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">##</span></span>[Service]<span class="hljs-meta">#</span><span class="bash"> Modify these two values and uncomment them <span class="hljs-keyword">if</span> you have</span><span class="hljs-meta">#</span><span class="bash"> repos with lots of files and get an HTTP error 500 because</span><span class="hljs-meta">#</span><span class="bash"> of that</span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">##</span></span><span class="hljs-meta">#</span><span class="bash">LimitMEMLOCK=infinity</span><span class="hljs-meta">#</span><span class="bash">LimitNOFILE=65535</span>RestartSec=2sType=simpleUser=rootGroup=rootWorkingDirectory=/www/wwwroot/code.demo.com/<span class="hljs-meta">#</span><span class="bash"> If using Unix socket: tells systemd to create the /run/gitea folder, <span class="hljs-built_in">which</span> will contain the gitea.sock file</span><span class="hljs-meta">#</span><span class="bash"> (manually creating /run/gitea doesn<span class="hljs-string">&#x27;t work, because it would not persist across reboots)</span></span><span class="hljs-meta">#</span><span class="bash">RuntimeDirectory=gitea</span>ExecStart=/www/wwwroot/code.demo.com/gitea web --config /www/wwwroot/code.demo.com/custom/conf/app.iniRestart=alwaysEnvironment=USER=root HOME=/home/ GITEA_WORK_DIR=/www/wwwroot/code.demo.com/<span class="hljs-meta">#</span><span class="bash"> If you want to <span class="hljs-built_in">bind</span> Gitea to a port below 1024, uncomment</span><span class="hljs-meta">#</span><span class="bash"> the two values below, or use socket activation to pass Gitea its ports as above</span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">##</span></span><span class="hljs-meta">#</span><span class="bash">CapabilityBoundingSet=CAP_NET_BIND_SERVICE</span><span class="hljs-meta">#</span><span class="bash">AmbientCapabilities=CAP_NET_BIND_SERVICE</span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">##</span></span>[Install]WantedBy=multi-user.target</code></pre><p>修改完毕后输入<code>:wq</code>退出vim编辑器。</p><p>启动gitea并设置开机自动启动：</p><pre><code class="hljs shell">systemctl start giteasystemctl enable gitea</code></pre><p>待以上步骤完成后，ssh到服务器重载设置文件并重启nginx服务：</p><pre><code class="hljs shell">sudo /etc/init.d/nginx reloadsudo /etc/init.d/nginx stopsudo /etc/init.d/nginx start</code></pre><p>现在打开浏览器访问 <a href="https://code.demo.com/">https://code.demo.com</a> 即可进行gitea的安装过程了。</p>]]></content>
    
    
    <categories>
      
      <category>仓库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CentOS</tag>
      
      <tag>宝塔</tag>
      
      <tag>gitea</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/10/25/hello-world/"/>
    <url>/2020/10/25/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
